<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flashlight Messenger</title>
  <script src="/_sdk/element_sdk.js"></script>
  <style>
    /* --- layout / theme --- */
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100%;
      width: 100%;
    }

    * { box-sizing: border-box; }

    .container { padding: 20px; max-width: 600px; margin: 0 auto; }

    h1 {
      color: #ffffff;
      text-align: center;
      margin: 0 0 30px 0;
      font-size: 28px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }

    .mode-selector { display:flex; gap:10px; margin-bottom:30px; }
    .mode-btn {
      flex:1; padding:16px; border:none; border-radius:12px; font-size:16px; font-weight:600;
      cursor:pointer; transition: all .3s; background: rgba(255,255,255,.2); color:#fff;
    }
    .mode-btn.active { background:#fff; color:#667eea; box-shadow:0 4px 12px rgba(0,0,0,.2); }

    .card {
      background:#ffffff; border-radius:16px; padding:24px; margin-bottom:20px;
      box-shadow:0 8px 24px rgba(0,0,0,0.15);
    }

    label { display:block; margin-bottom:8px; font-weight:600; color:#333; font-size:14px; }
    input, textarea {
      width:100%; padding:12px; border:2px solid #e0e0e0; border-radius:8px; font-size:16px;
      margin-bottom:16px; font-family:inherit; transition: border-color .3s;
    }
    input:focus, textarea:focus { outline:none; border-color:#667eea; }
    textarea { resize:vertical; min-height:100px; }

    .action-btn {
      width:100%; padding:16px; border:none; border-radius:12px; font-size:18px; font-weight:600;
      cursor:pointer; transition: all .3s; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      color:#ffffff; box-shadow:0 4px 12px rgba(102,126,234,0.4);
    }
    .action-btn:active { transform: translateY(2px); box-shadow:0 2px 8px rgba(102,126,234,0.4); }
    .action-btn:disabled { opacity:.5; cursor:not-allowed; }

    .status { text-align:center; padding:16px; border-radius:8px; margin-top:16px; font-weight:600; display:none; }
    .status.active { display:block; }
    .status.sending { background:#fff3cd; color:#856404; }
    .status.receiving { background:#d1ecf1; color:#0c5460; }
    .status.success { background:#d4edda; color:#155724; }
    .status.error { background:#f8d7da; color:#721c24; }

    #videoPreview { width:100%; border-radius:8px; margin-top:16px; display:none; background:#000; }
    #flashIndicator { width:100%; height:200px; border-radius:8px; margin-top:16px; background:#000; display:none; position:relative; overflow:hidden; transition: background .08s; }
    #flashIndicator.flash { background: #ffffff; }

    .received-message { background:#f0f0f0; padding:16px; border-radius:8px; margin-top:16px; display:none; }
    .received-message.show { display:block; }

    .modal-overlay { display:flex; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.85); z-index:1000; align-items:center; justify-content:center; }
    .modal-overlay.hidden { display:none; }
    .modal { background:#ffffff; border-radius:16px; padding:24px; max-width:500px; margin:20px; box-shadow:0 8px 32px rgba(0,0,0,.3); }
    .modal h2 { margin:0 0 16px 0; color:#333; font-size:22px; }
    .modal p { color:#666; line-height:1.6; margin:0 0 12px 0; font-size:15px; }

    .modal-buttons { display:flex; gap:12px; margin-top:12px; }
    .modal-btn { flex:1; padding:14px; border:none; border-radius:10px; font-size:16px; font-weight:600; cursor:pointer; }
    .modal-btn.primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; }
    .modal-btn.secondary { background:#e0e0e0; color:#333; }

    .info-text { color:#666; font-size:14px; margin-top:12px; line-height:1.5; }
    .warning-text { background:#fff3cd; color:#856404; padding:12px; border-radius:8px; font-size:13px; margin-top:12px; line-height:1.4; }
  </style>

  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
</head>
<body>
  <div class="container">
    <h1 id="appTitle">Flashlight Messenger</h1>

    <div class="mode-selector">
      <button class="mode-btn active" id="sendModeBtn">Send</button>
      <button class="mode-btn" id="receiveModeBtn">Receive</button>
    </div>

    <div id="sendMode" class="active">
      <div class="card">
        <label for="sendKeyword">Secret Keyword:</label>
        <input type="text" id="sendKeyword" placeholder="e.g., bobscommunication" value="bobscommunication">

        <label for="message">Your Message:</label>
        <textarea id="message" placeholder="Type your message here..."></textarea>

        <button class="action-btn" id="sendBtn">Send Message</button>

        <p class="info-text">Your message will be converted to light flashes. The receiver must use the same keyword.</p>
        <div class="warning-text">‚ö†Ô∏è <strong>Note:</strong> Flashlight control only works on some Android browsers (Chrome/Firefox). iOS Safari does not support torch control.</div>
      </div>

      <div id="flashIndicator" aria-hidden="true"></div>
      <div class="status" id="sendStatus"></div>
    </div>

    <div id="receiveMode" style="display:none;">
      <div class="card">
        <label for="receiveKeyword">Secret Keyword:</label>
        <input type="text" id="receiveKeyword" placeholder="e.g., bobscommunication" value="bobscommunication">
        <button class="action-btn" id="receiveBtn">Start Receiving</button>
        <p class="info-text">Point your camera at the flashing phone. Use the same keyword as the sender.</p>
      </div>

      <video id="videoPreview" autoplay playsinline muted></video>

      <div class="received-message" id="receivedMessage">
        <h3>Received Message:</h3>
        <p id="decodedMessage"></p>
      </div>

      <div class="status" id="receiveStatus"></div>
    </div>
  </div>

  <!-- Initial Permissions Popup -->
  <div class="modal-overlay" id="initialPermissionModal">
    <div class="modal">
      <h2>üì± Flashlight Messenger</h2>
      <p>This app uses light to send secret messages between phones!</p>

      <h3 style="font-size:18px; margin:20px 0 12px 0; color:#667eea;">How it works:</h3>

      <div style="background:#f8f9fa; padding:16px; border-radius:10px; margin-bottom:12px;">
        <div style="display:flex; gap:12px;">
          <span style="font-size:24px;">üì∑</span>
          <div>
            <strong style="color:#333;">Camera Access</strong>
            <p style="margin:4px 0 0 0; font-size:14px;">When you start Send or Receive your browser will ask for camera permission. This allows the app to control torch (if available) and detect flashes.</p>
          </div>
        </div>
      </div>

      <div style="background:#f8f9fa; padding:16px; border-radius:10px; margin-bottom:20px;">
        <div style="display:flex; gap:12px;">
          <span style="font-size:24px;">üî¶</span>
          <div>
            <strong style="color:#333;">Flashlight Control</strong>
            <p style="margin:4px 0 0 0; font-size:14px;">Works on some Android Chrome/Firefox with back camera. iOS Safari generally cannot toggle the torch.</p>
          </div>
        </div>
      </div>

      <div style="background:#fff3cd; padding:12px; border-radius:8px; margin-bottom:20px;">
        <p style="margin:0; font-size:13px; color:#856404;"><strong>‚ö†Ô∏è Important:</strong> iOS Safari does not support flashlight control, but may still receive messages via camera brightness detection.</p>
      </div>

      <div style="background:#e7f3ff; padding:12px; border-radius:8px; margin-bottom:20px;">
        <p style="margin:0; font-size:13px; color:#0c5460;"><strong>üîí Privacy:</strong> Your camera is only used locally on your device. No data is sent to any server.</p>
      </div>

      <div class="modal-buttons">
        <button class="modal-btn primary" id="acceptAllPermissions" style="flex:1;">Get Started</button>
        <button class="modal-btn secondary" id="dismissModal">Maybe later</button>
      </div>
    </div>
  </div>

<script>
  const defaultConfig = {
    app_title: "Flashlight Messenger",
    send_button_text: "Send Message",
    receive_button_text: "Start Receiving",
    primary_color: "#667eea",
    secondary_color: "#764ba2",
    background_color: "#ffffff",
    text_color: "#333333",
    button_text_color: "#ffffff"
  };

  let config = {};
  let videoStream = null;
  let isReceiving = false;
  let flashSequence = [];

  // ---------- encoding / decoding ----------
  function hashKeyword(keyword) {
    const hash = [];
    for (let i=0;i<keyword.length;i++) hash.push(keyword.charCodeAt(i));
    while (hash.length < 256) {
      for (let i=0;i<keyword.length && hash.length<256;i++) {
        hash.push((hash[hash.length-1]*31 + keyword.charCodeAt(i)) % 256);
      }
    }
    return hash;
  }

  function encodeMessage(message, keyword) {
    const hash = hashKeyword(keyword);
    const encoded = [];
    for (let i=0;i<message.length;i++) {
      const charCode = message.charCodeAt(i);
      const keyCode = hash[i % hash.length];
      encoded.push(charCode ^ keyCode);
    }
    return encoded;
  }

  function decodeMessage(encoded, keyword) {
    const hash = hashKeyword(keyword);
    let decoded = '';
    for (let i=0;i<encoded.length;i++) {
      const keyCode = hash[i % hash.length];
      decoded += String.fromCharCode(encoded[i] ^ keyCode);
    }
    return decoded;
  }

  function messageToFlashPattern(encoded) {
    const pattern = [];
    // start signal: three quick flashes separated by off
    pattern.push(1,0,1,0,1,0);
    encoded.forEach(num => {
      for (let i=7;i>=0;i--) pattern.push((num>>i)&1);
      pattern.push(0,0); // short pause between chars
    });
    // end signal
    pattern.push(1,0,1,0,1,0);
    return pattern;
  }

  function flashPatternToMessage(pattern) {
    const encoded = [];
    let i = 0;
    // find start sequence (1,0,1,0,1,0)
    while (i < pattern.length - 5) {
      if (pattern[i] === 1 && pattern[i+1] === 0 && pattern[i+2] === 1 && pattern[i+3] === 0 && pattern[i+4] === 1 && pattern[i+5] === 0) {
        i += 6;
        break;
      }
      i++;
    }
    // read bytes
    while (i + 7 < pattern.length) {
      let byte = 0;
      for (let b=0;b<8;b++) {
        byte = (byte<<1) | (pattern[i] === 1 ? 1 : 0);
        i++;
      }
      encoded.push(byte);
      // skip expected pause of two zeros (if present)
      if (pattern[i] === 0 && pattern[i+1] === 0) i += 2;
      // check for end signal
      if (i + 5 < pattern.length &&
          pattern[i] === 1 && pattern[i+1] === 0 && pattern[i+2] === 1 && pattern[i+3] === 0 && pattern[i+4] === 1 && pattern[i+5] === 0) {
        break;
      }
    }
    return encoded;
  }

  // ---------- helpers ----------
  function showStatus(el, text, type) {
    el.textContent = text;
    el.className = 'status';
    if (text) el.classList.add('active', type);
  }

  // Request a minimal camera stream to prompt permission (used by modal)
  async function requestCameraPermissionHint() {
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } } });
      s.getTracks().forEach(t => t.stop());
      return true;
    } catch (e) {
      console.warn('Permission request hint failed:', e);
      return false;
    }
  }

  // ---------- send message (flash) ----------
  async function sendMessage() {
    const message = document.getElementById('message').value.trim();
    const keyword = document.getElementById('sendKeyword').value.trim();
    const statusEl = document.getElementById('sendStatus');
    const flashIndicator = document.getElementById('flashIndicator');
    const sendBtn = document.getElementById('sendBtn');

    if (!message) { showStatus(statusEl, 'Please enter a message', 'error'); return; }
    if (!keyword) { showStatus(statusEl, 'Please enter a keyword', 'error'); return; }

    sendBtn.disabled = true;
    showStatus(statusEl, 'üì∑ Requesting camera access...', 'sending');

    let stream = null;
    let hiddenVideo = null;

    try {
      // Prefer back camera for torch support. Use exact facingMode where supported, fallback to ideal.
      const constraintsList = [
        { video: { facingMode: { exact: "environment" } } },
        { video: { facingMode: { ideal: "environment" } } },
        { video: true }
      ];

      for (const c of constraintsList) {
        try {
          stream = await navigator.mediaDevices.getUserMedia(c);
          break;
        } catch (e) {
          // try next constraint
        }
      }
      if (!stream) throw new Error('Could not get camera');

      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities ? track.getCapabilities() : {};

      // If torch not supported, inform user and stop.
      if (!capabilities.torch) {
        showStatus(statusEl, '‚ö†Ô∏è Flashlight not supported on this device/browser. Torch available only on some Android browsers with back camera.', 'error');
        stream.getTracks().forEach(t => t.stop());
        sendBtn.disabled = false;
        return;
      }

      // keep stream alive via hidden video element (user gesture already initiated)
      hiddenVideo = document.createElement('video');
      hiddenVideo.srcObject = stream;
      hiddenVideo.muted = true;
      hiddenVideo.playsInline = true;
      hiddenVideo.style.position = 'fixed';
      hiddenVideo.style.top = '-9999px';
      document.body.appendChild(hiddenVideo);
      try { await hiddenVideo.play(); } catch(e) { /* ignore autoplay quirks on some devices */ }

      flashIndicator.style.display = 'block';
      showStatus(statusEl, 'üì° Encoding and sending message...', 'sending');

      const encoded = encodeMessage(message, keyword);
      flashSequence = messageToFlashPattern(encoded);

      // Flash the message
      for (let i=0;i<flashSequence.length;i++) {
        const flashOn = flashSequence[i] === 1;
        try {
          await track.applyConstraints({ advanced: [{ torch: flashOn }] });
        } catch (e) {
          // Some implementations throw when writing same state rapidly; ignore but keep visual indicator
          console.warn('Torch constraint apply failed (ignored):', e);
        }

        if (flashOn) flashIndicator.classList.add('flash');
        else flashIndicator.classList.remove('flash');

        // short delay between toggles (tweak if needed)
        await new Promise(r => setTimeout(r, 200));
      }

      // ensure torch off
      try { await track.applyConstraints({ advanced: [{ torch: false }] }); } catch(e) {}
      flashIndicator.classList.remove('flash');

      // cleanup
      if (hiddenVideo) hiddenVideo.remove();
      stream.getTracks().forEach(t => t.stop());

      showStatus(statusEl, '‚úÖ Message sent successfully!', 'success');
      sendBtn.disabled = false;

      setTimeout(()=>{ flashIndicator.style.display = 'none'; }, 2000);

    } catch (err) {
      console.error('Camera error:', err);
      if (hiddenVideo) hiddenVideo.remove();
      if (stream) stream.getTracks().forEach(t => t.stop());

      if (err && err.name === 'NotAllowedError') {
        showStatus(statusEl, '‚ùå Camera permission denied. Please allow camera access and try again.', 'error');
      } else if (err && err.name === 'NotFoundError') {
        showStatus(statusEl, '‚ùå No camera found. Make sure your device has a back camera and try again.', 'error');
      } else {
        showStatus(statusEl, '‚ùå Error: ' + (err.message || err), 'error');
      }

      sendBtn.disabled = false;
    }
  }

  // ---------- receive (detect flashes) ----------
  async function startReceiving() {
    const keyword = document.getElementById('receiveKeyword').value.trim();
    const statusEl = document.getElementById('receiveStatus');
    const videoEl = document.getElementById('videoPreview');
    const receiveBtn = document.getElementById('receiveBtn');
    const receivedMessageEl = document.getElementById('receivedMessage');

    if (!keyword) { showStatus(statusEl, 'Please enter a keyword', 'error'); return; }

    if (isReceiving) {
      // stop
      if (videoStream) { videoStream.getTracks().forEach(t => t.stop()); videoStream = null; }
      videoEl.style.display = 'none';
      isReceiving = false;
      receiveBtn.textContent = config.receive_button_text || defaultConfig.receive_button_text;
      showStatus(statusEl, '', '');
      return;
    }

    receiveBtn.disabled = true;
    showStatus(statusEl, 'üì∑ Requesting camera access...', 'receiving');

    try {
      // Try environment/back camera first for best detection
      videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } } });

      videoEl.srcObject = videoStream;
      videoEl.style.display = 'block';
      isReceiving = true;
      receiveBtn.textContent = 'Stop Receiving';
      receiveBtn.disabled = false;
      receivedMessageEl.classList.remove('show');
      showStatus(statusEl, 'üì∑ Point camera at flashing phone...', 'receiving');

      // detection
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const detectedPattern = [];
      let prevIsFlash = null;
      const threshold = 180; // brightness threshold - adjust if too sensitive

      const detectInterval = setInterval(() => {
        if (!isReceiving) { clearInterval(detectInterval); return; }

        if (videoEl.videoWidth === 0) return;
        canvas.width = videoEl.videoWidth;
        canvas.height = videoEl.videoHeight;
        ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0,0,canvas.width, canvas.height);
        const data = imageData.data;

        // compute average brightness using a subsample to save CPU if large resolution
        let total = 0;
        let count = 0;
        const step = 4 * 20; // sample every 20th pixel (R,G,B,A)
        for (let i=0;i<data.length;i+=step) {
          const r = data[i], g = data[i+1], b = data[i+2];
          total += (r + g + b) / 3;
          count++;
        }
        const avg = total / Math.max(1, count);
        const isFlash = avg > threshold;

        if (prevIsFlash === null) prevIsFlash = isFlash;

        if (isFlash !== prevIsFlash) {
          detectedPattern.push(isFlash ? 1 : 0);
          prevIsFlash = isFlash;

          // if we have a decent-length capture, try decode
          if (detectedPattern.length > 30) {
            const encoded = flashPatternToMessage(detectedPattern);
            if (encoded.length > 0) {
              try {
                const decoded = decodeMessage(encoded, keyword);
                if (decoded && decoded.length > 0 && decoded.length < 1000) {
                  document.getElementById('decodedMessage').textContent = decoded;
                  receivedMessageEl.classList.add('show');
                  showStatus(statusEl, '‚úÖ Message received!', 'success');

                  // stop detection + camera
                  clearInterval(detectInterval);
                  if (videoStream) { videoStream.getTracks().forEach(t => t.stop()); videoStream = null; }
                  videoEl.style.display = 'none';
                  isReceiving = false;
                  receiveBtn.textContent = config.receive_button_text || defaultConfig.receive_button_text;
                }
              } catch (e) {
                // decoding failed: keep detecting
                console.warn('Decode attempt failed (continuing):', e);
              }
            }
          }
        }
      }, 100);

    } catch (err) {
      console.error('Camera error:', err);
      if (err && err.name === 'NotAllowedError') showStatus(statusEl, '‚ùå Camera permission denied. Please allow camera access and try again.', 'error');
      else if (err && err.name === 'NotFoundError') showStatus(statusEl, '‚ùå No camera found. Make sure your device has a camera.', 'error');
      else showStatus(statusEl, '‚ùå Error: ' + (err.message || err), 'error');

      isReceiving = false;
      receiveBtn.textContent = config.receive_button_text || defaultConfig.receive_button_text;
      receiveBtn.disabled = false;
    }
  }

  // ---------- UI wiring ----------
  document.getElementById('sendModeBtn').addEventListener('click', () => {
    document.getElementById('sendModeBtn').classList.add('active');
    document.getElementById('receiveModeBtn').classList.remove('active');
    document.getElementById('sendMode').classList.add('active');
    document.getElementById('receiveMode').style.display = 'none';
    if (isReceiving && videoStream) { videoStream.getTracks().forEach(t=>t.stop()); videoStream = null; isReceiving = false; }
  });

  document.getElementById('receiveModeBtn').addEventListener('click', () => {
    document.getElementById('receiveModeBtn').classList.add('active');
    document.getElementById('sendModeBtn').classList.remove('active');
    document.getElementById('receiveMode').style.display = 'block';
    document.getElementById('sendMode').classList.remove('active');
  });

  document.getElementById('sendBtn').addEventListener('click', sendMessage);
  document.getElementById('receiveBtn').addEventListener('click', startReceiving);

  // modal actions: hide + optionally request permission
  document.getElementById('acceptAllPermissions').addEventListener('click', async () => {
    document.getElementById('initialPermissionModal').classList.add('hidden');
    // try to prompt camera permission quietly
    await requestCameraPermissionHint();
  });
  document.getElementById('dismissModal').addEventListener('click', () => {
    document.getElementById('initialPermissionModal').classList.add('hidden');
  });

  // Element SDK integration (if available)
  async function onConfigChange(newConfig) {
    const appTitle = document.getElementById('appTitle');
    const sendBtn = document.getElementById('sendBtn');
    const receiveBtn = document.getElementById('receiveBtn');
    const gradient = document.querySelector('body');
    const actionBtns = document.querySelectorAll('.action-btn');

    appTitle.textContent = newConfig.app_title || defaultConfig.app_title;
    sendBtn.textContent = newConfig.send_button_text || defaultConfig.send_button_text;
    if (!isReceiving) receiveBtn.textContent = newConfig.receive_button_text || defaultConfig.receive_button_text;

    const primaryColor = newConfig.primary_color || defaultConfig.primary_color;
    const secondaryColor = newConfig.secondary_color || defaultConfig.secondary_color;
    const backgroundColor = newConfig.background_color || defaultConfig.background_color;
    const textColor = newConfig.text_color || defaultConfig.text_color;
    const buttonTextColor = newConfig.button_text_color || defaultConfig.button_text_color;

    gradient.style.background = `linear-gradient(135deg, ${primaryColor} 0%, ${secondaryColor} 100%)`;

    actionBtns.forEach(btn => {
      btn.style.background = `linear-gradient(135deg, ${primaryColor} 0%, ${secondaryColor} 100%)`;
      btn.style.color = buttonTextColor;
    });

    document.querySelectorAll('.card').forEach(card => card.style.background = backgroundColor);
    document.querySelectorAll('label').forEach(label => label.style.color = textColor);

    const activeBtn = document.querySelector('.mode-btn.active');
    if (activeBtn) activeBtn.style.color = primaryColor;
  }

  if (window.elementSdk) {
    window.elementSdk.init({
      defaultConfig,
      onConfigChange,
      mapToCapabilities: (config) => ({
        recolorables: [
          { get: () => config.primary_color || defaultConfig.primary_color, set: (value) => { config.primary_color = value; window.elementSdk.setConfig({ primary_color: value }); } },
          { get: () => config.secondary_color || defaultConfig.secondary_color, set: (value) => { config.secondary_color = value; window.elementSdk.setConfig({ secondary_color: value }); } },
          { get: () => config.background_color || defaultConfig.background_color, set: (value) => { config.background_color = value; window.elementSdk.setConfig({ background_color: value }); } },
          { get: () => config.text_color || defaultConfig.text_color, set: (value) => { config.text_color = value; window.elementSdk.setConfig({ text_color: value }); } },
          { get: () => config.button_text_color || defaultConfig.button_text_color, set: (value) => { config.button_text_color = value; window.elementSdk.setConfig({ button_text_color: value }); } }
        ],
        borderables: [], fontEditable: undefined, fontSizeable: undefined
      }),
      mapToEditPanelValues: (config) => new Map([
        ['app_title', config.app_title || defaultConfig.app_title],
        ['send_button_text', config.send_button_text || defaultConfig.send_button_text],
        ['receive_button_text', config.receive_button_text || defaultConfig.receive_button_text]
      ])
    });

    config = window.elementSdk.config;
    onConfigChange(config);
  } else {
    config = defaultConfig;
  }
</script>
</body>
</html>

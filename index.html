<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flasher Messaging ⚡</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.tailwindcss.com"></script>
<style>
body { background-color: #111; color: #fff; font-family: sans-serif; margin:0; padding:0;}
button { cursor:pointer; transition:all 0.2s;}
button:hover { opacity:0.85;}
#video { border-radius: 12px; width: 100%; max-width: 400px;}
#lightIndicator { width: 60px; height:60px; border-radius:50%; background:#ff0000; box-shadow:0 0 20px #ff0000; transition:0.2s;}
#messageOutput { background:#000; color:#0f0; padding:10px; border-radius:8px; height:100px; overflow-y:auto; }
#detectionArea { position:absolute; border:2px dashed #0f0; pointer-events:none; }
</style>
</head>
<body class="flex flex-col items-center p-4">

<h1 class="text-2xl font-bold mb-4">Flasher Messaging ⚡</h1>
<p class="mb-4 opacity-70 text-center">Point your camera at the flashing device to receive messages.</p>

<div class="flex gap-2 mb-4">
  <button class="bg-blue-600 px-4 py-2 rounded" onclick="startReceive()">Start Receiving</button>
  <button class="bg-green-600 px-4 py-2 rounded" onclick="sendFlashMessage()">Send Flash</button>
  <button class="bg-purple-600 px-4 py-2 rounded" onclick="togglePrivateSync()">Private Sync</button>
</div>

<div class="mb-4 relative">
  <video id="video" autoplay playsinline></video>
  <div id="detectionArea"></div>
</div>

<div class="flex flex-col items-center mb-4">
  <div id="lightIndicator"></div>
  <p class="opacity-70 text-sm mt-2">Indicator turns green when a flash is detected</p>
</div>

<div id="messageOutput"></div>

<script>
let stream, track;
let receiveActive=false;
let morseBuffer="", flashStart=null, lastBitTime=0;
let privateSync=false;
let detectionRect=null;

const dotTime = 150; // ms for dot
const dashTime = 450; // ms for dash
const gapTime = 500; // ms to detect end of letter

// Morse code table
const morseTable = {
  '.-':'A','-...':'B','-.-.':'C','-..':'D','.':'E',
  '..-.':'F','--.':'G','....':'H','..':'I','.---':'J',
  '-.-':'K','.-..':'L','--':'M','-.':'N','---':'O',
  '.--.':'P','--.-':'Q','.-.':'R','...':'S','-':'T',
  '..-':'U','...-':'V','.--':'W','-..-':'X','-.--':'Y',
  '--..':'Z','-----':'0','.----':'1','..---':'2','...--':'3',
  '....-':'4','.....':'5','-....':'6','--...':'7','---..':'8','----.':'9',' ':' '
};

function togglePrivateSync(){
  privateSync=!privateSync;
  alert(privateSync?'Private sync enabled':'Private sync disabled');
}

async function initCamera(){
  if(stream) return;
  stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  const video = document.getElementById('video');
  video.srcObject = stream;
  track = stream.getVideoTracks()[0];
  // default detection area = whole video
  detectionRect = {x:0,y:0,width:video.videoWidth,height:video.videoHeight};
}

function startReceive(){
  initCamera().then(()=>{
    receiveActive=true;
    const video=document.getElementById('video');
    const canvas=document.createElement('canvas');
    const ctx=canvas.getContext('2d');
    const indicator=document.getElementById('lightIndicator');
    const output=document.getElementById('messageOutput');

    function readFrame(){
      if(!receiveActive) return;
      canvas.width=video.videoWidth;
      canvas.height=video.videoHeight;
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
      const area=detectionRect || {x:0,y:0,width:canvas.width,height:canvas.height};
      const frame=ctx.getImageData(area.x,area.y,area.width,area.height).data;

      // calculate average brightness
      let brightness=0;
      for(let i=0;i<frame.length;i+=4){
        brightness += 0.299*frame[i]+0.587*frame[i+1]+0.114*frame[i+2];
      }
      brightness /= frame.length/4;

      const threshold=200;
      const now=performance.now();
      let bit=brightness>threshold ? 1 : 0;
      indicator.style.background=bit?'#0f0':'#f00';
      indicator.style.boxShadow=bit?'0 0 30px #0f0':'0 0 20px #f00';

      // detect flashes
      if(bit && flashStart===null) flashStart=now;
      if(!bit && flashStart!==null){
        const duration=now-flashStart;
        flashStart=null;
        morseBuffer+=duration<dashTime ? '.' : '-';
        lastBitTime=now;
      }

      // end of letter detection
      if(!bit && morseBuffer && now-lastBitTime>gapTime){
        // decode
        let letter=privateSync? decodePrivate(morseBuffer) : morseTable[morseBuffer];
        if(letter) output.innerText+=letter;
        morseBuffer="";
      }

      requestAnimationFrame(readFrame);
    }
    readFrame();
  });
}

// Simple placeholder private decoding: scramble dots/dashes
function decodePrivate(buffer){
  let swap={'.':'-','-':'.'};
  let swapped='';
  for(let c of buffer) swapped+=swap[c]||c;
  return morseTable[swapped]||'?';
}

async function sendFlashMessage(){
  const msg=prompt('Type message to flash:');
  if(!msg) return;
  if(!track) await initCamera();
  const caps=track.getCapabilities();
  if(!caps.torch){alert('Torch not supported');return;}
  let i=0;
  function nextChar(){
    if(i>=msg.length){track.applyConstraints({advanced:[{torch:false}]});return;}
    const binary=(msg[i].charCodeAt(0).toString(2)).padStart(8,'0');
    let b=0;
    function nextBit(){
      if(b>=binary.length){track.applyConstraints({advanced:[{torch:false}]});return setTimeout(()=>{i++;nextChar();},250);}
      track.applyConstraints({advanced:[{torch:binary[b]==='1'}]});
      b++;
      setTimeout(nextBit,150);
    }
    nextBit();
  }
  nextChar();
}
</script>

</body>
</html>
